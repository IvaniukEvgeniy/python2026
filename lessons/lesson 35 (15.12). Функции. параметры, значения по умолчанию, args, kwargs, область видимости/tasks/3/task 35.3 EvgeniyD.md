# Практическое задание 35.3

## Задания

### Описание задачи
В предыдущих блоках ты научился работать с позиционными и именованными аргументами, а также значениями по умолчанию. Сейчас мы переходим к созданию гибких функций, которые могут работать с переменным количеством данных. Это критически важно для написания универсального кода, способного обрабатывать заранее неизвестное число входных параметров, что часто встречается в реальных задачах, например, при агрегации данных или настройке объектов.

Твоя задача — создать функцию `merge_data`, которая объединяет информацию из нескольких источников. Функция должна принимать обязательные позиционные аргументы, произвольное количество дополнительных позиционных данных и произвольное количество именованных настроек, а затем возвращать структурированный результат.

**Контекст:** Представь, что ты пишешь модуль для сбора статистики. Разные части системы передают числовые данные (например, результаты замеров), а также метаданные в виде пар ключ-значение (например, единицы измерения, источник данных). Нужно уметь гибко принимать все эти данные и формировать из них единый отчет.

### Пример входных и выходных данных

**Пример 1: Базовый вызов**
```python
result = merge_data("Температура", 23.5, 24.1, 22.8, unit="C", source="датчик_1")
print(result)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Температура',
    'values': (23.5, 24.1, 22.8),
    'meta': {'unit': 'C', 'source': 'датчик_1'}
}
```

**Пример 2: Вызов без дополнительных позиционных аргументов**
```python
result = merge_data("Давление", precision=2, sensor="A")
print(result)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Давление',
    'values': (),
    'meta': {'precision': 2, 'sensor': 'A'}
}
```

**Пример 3: Вызов с распаковкой коллекций**
```python
additional_readings = [101.3, 101.5, 101.4]
extra_info = {"location": "лаб. 5", "time": "12:00"}
result = merge_data("Атмосферное давление", *additional_readings, **extra_info)
print(result)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Атмосферное давление',
    'values': (101.3, 101.5, 101.4),
    'meta': {'location': 'лаб. 5', 'time': '12:00'}
}
```

**Пояснение к примерам:**
- Первый аргумент (`name`) — обязательный позиционный, это название набора данных.
- Все последующие позиционные аргументы, переданные после `name`, должны быть собраны в кортеж `values`.
- Все именованные аргументы должны быть собраны в словарь `meta`.
- Если дополнительных позиционных аргументов нет, `values` должен быть пустым кортежем.
- Если именованных аргументов нет, `meta` должен быть пустым словарем.

### Критерии проверки и ограничения
1.  Функция должна называться `merge_data`.
2.  Функция должна принимать как минимум один обязательный позиционный аргумент (`name`).
3.  Для сбора переменного числа позиционных аргументов используй `*args`.
4.  Для сбора переменного числа именованных аргументов используй `**kwargs`.
5.  Функция должна возвращать словарь с ключами `'name'`, `'values'` и `'meta'`.
6.  Значение по ключу `'values'` должно быть кортежем.
7.  Значение по ключу `'meta'` должно быть словарем.
8.  **Запрещено** использовать темы из будущих блоков: область видимости, локальные/глобальные переменные, `global`, замыкания, интеграция.
9.  Задача должна решаться строго в рамках блока 3: *args, **kwargs, переменное число аргументов, распаковка, кортеж, словарь.

### Решение задачи (псевдокод)
1.  Объяви функцию с именем `merge_data`.
2.  Первым параметром укажи `name` (обязательный позиционный аргумент).
3.  Вторым параметром укажи `*args` для сбора всех оставшихся позиционных аргументов.
4.  Третьим параметром укажи `**kwargs` для сбора всех именованных аргументов.
5.  В теле функции создай пустой словарь `result`.
6.  Добавь в словарь `result` пару ключ-значение: ключ `'name'`, значение — аргумент `name`.
7.  Добавь в словарь `result` пару ключ-значение: ключ `'values'`, значение — кортеж, созданный из `args`.
8.  Добавь в словарь `result` пару ключ-значение: ключ `'meta'`, значение — словарь `kwargs`.
9.  Верни словарь `result` из функции.

### Рекомендации
-   **Вынести в отдельную функцию:** В данной задаче вся логика инкапсулирована в одну функцию `merge_data`. Выносить что-либо в дополнительные функции не требуется, так как операция является атомарной и соответствует цели блока — освоению `*args` и `**kwargs`.
-   **PEP8:**
    -   Используй осмысленные имена параметров. `name`, `*args`, `**kwargs` являются стандартными и понятными в данном контексте.
    -   После определения функции оставь две пустые строки перед следующим блоком кода (например, перед вызовами функции для тестирования).
