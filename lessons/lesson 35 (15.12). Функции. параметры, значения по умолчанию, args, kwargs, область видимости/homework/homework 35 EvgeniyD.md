# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **Функция для форматирования данных о товаре**
    -   **Описание задачи:** Тренирует базовое объявление функции, использование позиционных и именованных аргументов, а также четкое разделение между печатью (`print`) и возвратом значения (`return`). Задача учит проектировать функцию, которая получает данные, обрабатывает их и возвращает готовый результат.
    -   **Пример (вход → выход):**
        -   `format_product("Ноутбук", 89999, "шт")` → `"Ноутбук: 89999 руб./шт"`
        -   `format_product(price=150, name="Молоко", unit="л")` → `"Молоко: 150 руб./л"`
        -   `format_product("Книга", 500)` → `"Книга: 500 руб./шт"` (используется значение по умолчанию для `unit`).
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `format_product`.
        -   Она должна принимать три параметра: `name` (название), `price` (цена), `unit` (единица измерения). Параметр `unit` должен иметь значение по умолчанию `"шт"`.
        -   Функция должна **возвращать** строку в формате `"{name}: {price} руб./{unit}"`, а не печатать ее.
        -   Функция должна корректно работать как с позиционной, так и с именованной передачей аргументов.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `format_product` с параметрами `name`, `price` и `unit` (со значением по умолчанию `"шт"`).
        2.  Внутри функции создай строку `result`, объединив значения параметров в требуемом формате.
        3.  Верни (`return`) строку `result` из функции.
    -   **Рекомендации:**
        -   **PEP8:** Имя функции должно быть в `snake_case`. После объявления функции оставь две пустые строки. Длина строки кода не должна превышать 79 символов.

2.  **Безопасное добавление заметок с тегами**
    -   **Описание задачи:** Закрепляет понимание "ловушки изменяемого значения по умолчанию" и применение безопасного паттерна с `None`. Также тренирует работу со списками (добавление элементов, создание копии).
    -   **Пример (вход → выход):**
        -   Первый вызов: `add_note("Купить хлеб", ["еда"], notes=None)` → возвращает `[{"text": "Купить хлеб", "tags": ["еда"]}]`
        -   Второй вызов: `add_note("Позвонить маме", ["важно"], notes=None)` → возвращает `[{"text": "Позвонить маме", "tags": ["важно"]}]` (а не объединенный список с первой заметкой!).
        -   Вызов с передачей своего списка: `my_notes = []; add_note("Задача 1", [], my_notes)` → модифицирует `my_notes`, добавляя в него словарь.
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_note`.
        -   Параметры: `text` (текст заметки), `tags` (список тегов), `notes` (список для хранения заметок). Параметр `notes` должен иметь безопасное значение по умолчанию.
        -   Функция должна добавлять в список `notes` новый словарь с ключами `"text"` и `"tags"`.
        -   **Критически важно:** При вызовах `add_note("текст1", [])` и `add_note("текст2", [])` должны создаваться два независимых списка заметок, а не один общий.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_note` с параметрами `text`, `tags` и `notes` (со значением по умолчанию `None`).
        2.  Внутри функции проверь, равен ли `notes` `None`.
        3.  Если да, создай новый пустой список и присвой его переменной `notes`.
        4.  Создай словарь `note_dict` с ключами `"text"` и `"tags"`.
        5.  Добавь (`append`) `note_dict` в список `notes`.
        6.  Верни (`return`) список `notes`.
    -   **Рекомендации:**
        -   Для проверки на `None` используй оператор `is`: `if notes is None:`.
        -   **PEP8:** Используй отступ в 4 пробела для тела функции и блоков `if`.

3.  **Универсальный калькулятор счета**
    -   **Описание задачи:** Развивает навык использования `*args` для работы с переменным количеством аргументов и `**kwargs` для обработки дополнительных параметров (например, чаевые). Интегрирует несколько изученных концепций.
    -   **Пример (вход → выход):**
        -   `calculate_total(100, 200, 350)` → возвращает `650` (сумма позиционных аргументов).
        -   `calculate_total(100, 200, 350, discount=0.1)` → возвращает `585` (сумма 650 минус 10% = 585).
        -   `calculate_total(500, tip=0.15)` → возвращает `575` (500 + 15% чаевых). Обрати внимание, что `tip` обрабатывается, даже если он единственный именованный аргумент.
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate_total`.
        -   Использовать `*args` для сбора всех позиционных аргументов (стоимостей блюд).
        -   Использовать `**kwargs` для сбора всех именованных аргументов (`discount` - скидка в долях, `tip` - чаевые в долях).
        -   Сначала вычисляется сумма всех `args`. Затем, если передан `discount`, сумма умножается на `(1 - discount)`. Затем, если передан `tip`, к результату добавляется `результат * tip`.
        -   Функция должна возвращать итоговое число (можно округлить до 2 знаков).
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_total` с параметрами `*args` и `**kwargs`.
        2.  Вычисли `subtotal` как сумму всех значений в `args`.
        3.  Инициализируй переменную `result` значением `subtotal`.
        4.  Если в словаре `kwargs` есть ключ `"discount"`, умножь `result` на `(1 - kwargs["discount"])`.
        5.  Если в словаре `kwargs` есть ключ `"tip"`, прибавь к `result` значение `result * kwargs["tip"]`.
        6.  Верни (`return`) `result`.
    -   **Рекомендации:**
        -   Для безопасного получения значений из `kwargs` используй метод `.get()`: `discount = kwargs.get("discount", 0)`.
        -   **PEP8:** Пробелы вокруг операторов (`=`, `*`, `+`).

4.  **Локальный счетчик и глобальный лог**
    -   **Описание задачи:** Тренирует понимание области видимости переменных. Нужно создать функцию, которая использует и изменяет свою собственную локальную переменную-счетчик, а также взаимодействует с глобальным списком для логирования, демонстрируя разницу между `global` и локальной областью.
    -   **Описание задачи:** Есть глобальный список `action_log`. Нужно создать функцию `perform_action(action_name)`, которая:
        a) Увеличивает свой внутренний счетчик вызовов (локальная переменная, сохраняющая состояние между вызовами этой конкретной функции — используй замыкание или атрибут функции, но в рамках урока можно смоделировать через `nonlocal` или `global`? Для простоты и в рамках темы используй `global` для лога и локальную переменную, инициализируемую вне внутренней функции, для счетчика).
        **Упрощенная постановка в рамках урока:**
        Создай функцию `track_action(action_name)`, которая использует глобальную переменную `call_count` и глобальный список `action_log`.
        -   При каждом вызове увеличивает `call_count` на 1.
        -   Добавляет в `action_log` строку вида `"#{call_count}: {action_name}"`.
        -   Возвращает текущее значение `call_count`.
    -   **Пример (вход → выход):**
        ```python
        # Предположим, call_count = 0, action_log = []
        print(track_action("login")) # -> 1
        print(track_action("search")) # -> 2
        print(action_log) # -> ['#1: login', '#2: search']
        print(call_count) # -> 2
        ```
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `track_action`.
        -   Должны существовать глобальные переменные `call_count` (число) и `action_log` (список), инициализированные до вызовов функции.
        -   Внутри функции нужно явно указать (`global`), что ты работаешь с этими глобальными переменными.
        -   Функция должна изменять обе глобальные переменные и возвращать новое значение счетчика.
    -   **Решение (псевдокод):**
        1.  В глобальной области видимости создай переменную `call_count = 0` и список `action_log = []`.
        2.  Объяви функцию `track_action` с параметром `action_name`.
        3.  Внутри функции объяви (`global`), что `call_count` и `action_log` являются глобальными переменными.
        4.  Увеличь `call_count` на 1.
        5.  Сформируй строку лога и добавь ее в список `action_log`.
        6.  Верни (`return`) значение `call_count`.
    -   **Рекомендации:**
        -   Использование `global` — это явное решение, которое делает зависимости функции очевидными, но в более сложном коде его стоит избегать. В данной задаче это учебный пример.
        -   **PEP8:** Имена глобальных переменных также в `snake_case`. `global` пишется с новой строки с отступом.
